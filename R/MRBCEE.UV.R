MRBCEE.UV=function(by,bX,byse,bXse,LD=LD,Rxy,cluster.index,Nmin=F,tauvec=seq(3,50,by=2),max.iter=100,max.eps=0.001,ebic.gamma=1,ebic.adjustment=1,rho=2,maxdiff=1.5,parametric=F,sampling.time=0,sampling.frac=0.5,theta.ini=F,gamma.ini=F,reliability.thres=reliability.thres){
########################### Basic information #######################
by=by/byse
byseinv=1/byse
bX=bX*byseinv
bXse=bXse*byseinv
byse1=byse
byse=byse/byse
m=length(bX)
if(Nmin==F){
Nmin=m
}
Theta=matrixInverse(LD)
a=matrixsqrt(LD)
RC=a$w
TC=a$wi
byinv=matrixVectorMultiply(Theta,by)
bXinv=matrixVectorMultiply(Theta,bX)
tilde.y=matrixVectorMultiply(TC,by)
tilde.X=matrixVectorMultiply(TC,bX)
Bt=t(bXinv)
BtB=sum(Bt*bX)
Thetarho=matrixInverse(LD+rho*diag(m))
r=reliability.adj.uv(bX,bXse,Theta=Theta,thres=reliability.thres)
r=c(r,1)
Rxy=t(t(Rxy)*r)*r
############################ Initial Estimate #######################
if(theta.ini[1]==F){
fit0=varbvs(X=RC,Z=tilde.X,y=tilde.y,verbose=F)
gamma.ini=fit0$beta*(fit0$pip>0.8)
theta.ini=fit0$beta.cov[-1]}
############################## Tuning Parameter ######################
w=length(tauvec)
Btheta=c(1:w)
Bgamma=matrix(0,m,w)
Bbic=tauvec
for(j in length(tauvec):1){
error=1
iter=1
theta=theta.ini
gamma=gamma.ini
gamma1=gamma
delta=gamma1
while(error>max.eps&iter<max.iter){
theta1=theta
indvalid=which(gamma1==0)
Hinv=1/(BtB-sum(bXse[indvalid]^2)*Rxy[1,1])
g=sum(Bt*(by-matrixVectorMultiply(LD,gamma)))-sum(bXse[indvalid])*Rxy[2,1]
theta=g*Hinv
########################### update gamma ############################
gamma=c(matrixVectorMultiply(Thetarho,c(by-bX*theta-delta+rho*gamma1)))
gamma1=mcp(gamma+delta/rho,tauvec[j]/rho)
delta=delta+rho*(gamma-gamma1)

iter=iter+1
if(iter>3){
error=abs(theta-theta1)
}
}
Btheta[j]=theta
Bgamma[,j]=gamma1
df1=sum(gamma1!=0)
res=by-bX*theta-matrixVectorMultiply(LD,gamma)
rss=sum(res*c(matrixVectorMultiply(Theta,res)))
Bbic[j]=Nmin*log(rss)+(log(Nmin)+ebic.gamma*log(m))*df1
}
######################## Inference #################################
jstar=which.min(Bbic)
theta=Btheta[jstar]
gamma=Bgamma[,jstar]
error=1
iter=1
theta=theta
gamma=gamma
names(gamma)=rownames(bX)
indgamma=which(gamma!=0)
indvalid=which(gamma==0)
res=by-bX*theta-matrixVectorMultiply(LD,gamma)
if(sampling.time==0){
bZ=as.matrix(cbind(bX,LD[,indgamma]))
bZinv=Theta%*%bZ
H=t(bZ)%*%bZinv
H[1,1]=H[1,1]-sum(bXse[indvalid]^2)*Rxy[1,1]
H=matrixInverse(H)
Hat=bZ%*%(H%*%t(bZ))
Hat=1-diag(Hat)
Hat[Hat<0.5]=0.5
S=LD*0
res=res/Hat
for(j in 1:max(cluster.index)){
a=which(cluster.index==j)
S[a,a]=outer(res[a],res[a])
}
COV=H%*%(t(bZinv)%*%S%*%bZinv)%*%H
theta.se=sqrt(diag(COV))[1]
}else{
ThetaList=c(1:sampling.time)
for(j in 1:sampling.time){
cluster.sampling=sample(1:max(cluster.index),round(sampling.frac*max(cluster.index)),replace=F)
indj=which(cluster.index%in%cluster.sampling)
indj=sort(indj)
LDj=Matrix(LD[indj,indj],sparse=T)
Thetaj=solve(LDj)
Bt <- as.matrix(t(bX[indj])%*%Thetaj)
BtB=c(Bt%*%bX[indj])
indvalidj=intersect(indvalid,indj)
Hinv=1/(BtB-sum(bXse[indvalidj]^2)*Rxy[1,1])
g=sum(Bt*(by[indj]-matrixVectorMultiply(LD[indj,indgamma],gamma[indgamma])))-sum(bXse[indvalidj])*Rxy[2,1]
thetaj=g*Hinv
ThetaList[j]=thetaj
}
theta.se=sd(ThetaList)*sqrt((m-length(theta))/(m-length(theta)-length(indgamma)))
}

A=list()
A$theta=theta
A$gamma=gamma
A$theta.se=theta.se
A$Bic=Bbic
A$theta.ini=theta.ini
A$gamma.ini=gamma.ini
A$reliability.adjust=r
return(A)
}
